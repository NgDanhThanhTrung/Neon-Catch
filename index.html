<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Catch - One by One Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #050510;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        .ui-container {
            display: flex;
            justify-content: space-between;
            width: 480px;
            margin-bottom: 10px;
            z-index: 5;
        }

        .stat-box { text-align: center; min-width: 80px; }
        .label { font-size: 0.65rem; color: #666; text-transform: uppercase; letter-spacing: 2px; }
        .value { font-size: 1.5rem; font-weight: bold; color: #00f2ff; text-shadow: 0 0 10px #00f2ff; }
        .lives-value { color: #ff00ff; text-shadow: 0 0 10px #ff00ff; }
        .combo-value { color: #ffea00; text-shadow: 0 0 10px #ffea00; }

        #canvas-container {
            position: relative;
            border-radius: 15px;
            padding: 5px;
            background: linear-gradient(45deg, #e94560, #00f2ff, #7000ff);
            background-size: 200% 200%;
            animation: borderFlow 4s linear infinite;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        @keyframes borderFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        canvas {
            background: #08081a;
            border-radius: 10px;
            display: block;
            cursor: none;
            touch-action: none;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 10px;
            transition: opacity 0.5s ease;
        }

        #start-overlay { background: rgba(5, 5, 20, 0.95); }
        #game-over-overlay { background: rgba(15, 5, 5, 0.95); display: none; }

        h1 { font-size: 3rem; margin: 0; letter-spacing: 5px; text-align: center; }
        .neon-blue { color: #00f2ff; text-shadow: 0 0 20px #00f2ff; }
        .neon-red { color: #e94560; text-shadow: 0 0 20px #e94560; }

        button {
            padding: 15px 45px;
            font-size: 1.2rem;
            background: transparent;
            border: 2px solid #00f2ff;
            border-radius: 50px;
            color: #00f2ff;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s;
            margin-top: 30px;
        }

        button:hover { 
            background: #00f2ff; 
            color: #000; 
            box-shadow: 0 0 30px #00f2ff; 
            transform: scale(1.05);
        }

        #powerup-status {
            height: 30px;
            margin-top: 15px;
            font-weight: bold;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }

        #milestone-text {
            position: absolute;
            top: 35%;
            width: 100%;
            text-align: center;
            font-size: 2.5rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
        }

        .pop-animation { animation: popFade 1s ease-out forwards; }
        @keyframes popFade {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(3px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-5px, 0, 0); }
            40%, 60% { transform: translate3d(5px, 0, 0); }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div class="ui-container">
        <div class="stat-box">
            <div class="label">Cấp độ</div>
            <div id="levelVal" class="value">1</div>
        </div>
        <div class="stat-box">
            <div class="label">Điểm số</div>
            <div id="scoreVal" class="value">0</div>
        </div>
        <div class="stat-box">
            <div class="label">Mạng</div>
            <div id="livesVal" class="value lives-value">3</div>
        </div>
        <div class="stat-box">
            <div class="label">Combo</div>
            <div id="comboVal" class="value combo-value">0</div>
        </div>
    </div>

    <div id="canvas-container">
        <div id="milestone-text"></div>
        <canvas id="gameCanvas" width="480" height="600"></canvas>

        <div id="start-overlay" class="overlay">
            <h1 class="neon-blue">NEON CATCH</h1>
            <p style="color: #888; margin-top: 15px;">Hứng từng quả một - Càng nhanh càng khó!</p>
            <button onclick="startGame()">BẮT ĐẦU</button>
        </div>

        <div id="game-over-overlay" class="overlay">
            <h1 class="neon-red">THẤT BẠI</h1>
            <div style="text-align: center; margin-top: 20px;">
                <p id="finalScoreText" style="font-size: 1.5rem; margin: 5px 0;">Điểm: 0</p>
                <p id="highScoreText" style="color: #aaa;">Kỷ lục: 0</p>
            </div>
            <button onclick="resetGame()">THỬ LẠI</button>
        </div>
    </div>
    
    <div id="powerup-status"></div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.getElementById("scoreVal");
        const livesElement = document.getElementById("livesVal");
        const comboElement = document.getElementById("comboVal");
        const levelElement = document.getElementById("levelVal");
        const powerupStatus = document.getElementById("powerup-status");
        const startOverlay = document.getElementById("start-overlay");
        const gameOverOverlay = document.getElementById("game-over-overlay");
        const milestoneBox = document.getElementById("milestone-text");

        let audioCtx = null;
        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(freq, type = 'square', duration = 0.1, vol = 0.1) {
            if (!audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch (e) {}
        }

        let score = 0, lives = 3, combo = 0, level = 1;
        let highScore = localStorage.getItem("neonCatchHighScore") || 0;
        let isGameRunning = false;
        let particles = [];
        let objects = []; 
        let powerups = [];
        let activePowerup = null, powerupTimer = null;
        let gridOffset = 0;

        const PADDLE_DEFAULT_WIDTH = 100;

        let paddle = { 
            width: PADDLE_DEFAULT_WIDTH, 
            height: 15, 
            x: 190, 
            y: 560, 
            color: "#e94560", 
            targetX: 190 
        };

        function showMilestone(text, color = "#fff") {
            milestoneBox.innerText = text;
            milestoneBox.style.color = color;
            milestoneBox.classList.remove('pop-animation');
            void milestoneBox.offsetWidth; 
            milestoneBox.classList.add('pop-animation');
        }

        function createObject() {
            // Chỉ tạo bóng mới nếu không có bóng nào trên màn hình
            if (objects.length > 0) return;

            const isObstacle = level >= 2 && Math.random() < 0.2; // 20% là chướng ngại vật đỏ
            const type = isObstacle ? 'OBSTACLE' : 'NORMAL';
            const radius = isObstacle ? 12 : 10;
            const baseSpeed = 4 + (level * 0.7); // Tốc độ cơ bản tăng theo level
            
            objects.push({
                x: Math.random() * (canvas.width - radius * 2) + radius,
                y: -radius,
                radius: radius,
                type: type,
                color: isObstacle ? '#ff0000' : `hsl(${Math.random() * 360}, 100%, 60%)`,
                speedY: activePowerup === 'SLOW' ? baseSpeed * 0.5 : baseSpeed,
                speedX: (Math.random() - 0.5) * (level > 3 ? 8 : 4)
            });
        }

        function spawnPowerup() {
            const types = [
                { type: 'WIDE', color: '#ffea00', label: 'THANH CHẮN LỚN' },
                { type: 'SLOW', color: '#00ff88', label: 'THỜI GIAN CHẬM' },
                { type: 'LIFE', color: '#00f2ff', label: 'HỒI PHỤC' }
            ];
            const chosen = types[Math.floor(Math.random() * types.length)];
            powerups.push({
                x: Math.random() * (canvas.width - 40) + 20,
                y: -20, size: 20, type: chosen.type, color: chosen.color, label: chosen.label, speedY: 3
            });
        }

        function applyPowerup(item) {
            if (item.type === 'LIFE') {
                lives++;
                livesElement.innerText = lives;
                playSound(1200, 'sine', 0.3);
                showMilestone("+1 MẠNG", "#00f2ff");
                return;
            }

            clearTimeout(powerupTimer);
            resetPowerupEffects();
            activePowerup = item.type;
            powerupStatus.innerText = item.label;
            powerupStatus.style.color = item.color;
            playSound(600, 'sine', 0.2);

            if (item.type === 'WIDE') paddle.width = 220;
            else if (item.type === 'SLOW') objects.forEach(o => o.speedY *= 0.5);

            powerupTimer = setTimeout(resetPowerupEffects, 8000);
        }

        function resetPowerupEffects() {
            activePowerup = null;
            paddle.width = PADDLE_DEFAULT_WIDTH;
            powerupStatus.innerText = "";
        }

        function triggerShake() {
            const container = document.getElementById('canvas-container');
            container.classList.add('shake');
            setTimeout(() => container.classList.remove('shake'), 400);
        }

        function update() {
            if (!isGameRunning) return;

            paddle.x += (paddle.targetX - paddle.x) * 0.25;

            // Logic chỉ cho 1 bóng rơi
            if (objects.length === 0) {
                createObject();
            }

            // Xử lý vật thể
            for (let i = objects.length - 1; i >= 0; i--) {
                let obj = objects[i];
                obj.y += obj.speedY;
                obj.x += obj.speedX;

                if (obj.x + obj.radius > canvas.width || obj.x - obj.radius < 0) {
                    obj.speedX *= -1;
                    playSound(200, 'sine', 0.05, 0.02);
                }

                if (obj.y + obj.radius > paddle.y && obj.y - obj.radius < paddle.y + paddle.height &&
                    obj.x > paddle.x && obj.x < paddle.x + paddle.width) {
                    
                    if (obj.type === 'OBSTACLE') {
                        lives--;
                        combo = 0;
                        triggerShake();
                        playSound(100, 'sawtooth', 0.4, 0.2);
                        showMilestone("NGUY HIỂM!", "#ff0000");
                    } else {
                        combo++;
                        score += (1 + Math.floor(combo / 10));
                        
                        if (combo % 10 === 0) {
                            showMilestone(`${combo} COMBO!`, "#ffea00");
                            playSound(600 + combo, 'sine', 0.2);
                        }
                        
                        // Tỷ lệ xuất hiện vật phẩm bổ trợ
                        if (Math.random() < 0.15) spawnPowerup();
                        
                        playSound(400 + Math.min(combo * 5, 400), 'sine', 0.05);
                        createParticles(obj.x, obj.y, obj.color);
                    }
                    
                    scoreElement.innerText = score;
                    comboElement.innerText = combo;
                    livesElement.innerText = lives;
                    objects.splice(i, 1); // Xóa bóng hiện tại để quả sau rơi xuống

                    if (Math.floor(score / 20) + 1 > level) {
                        level++;
                        levelElement.innerText = level;
                        showMilestone(`CẤP ${level}`, "#00f2ff");
                        playSound(800, 'triangle', 0.5);
                    }

                    if (lives <= 0) endGame();
                    continue;
                }

                if (obj.y - obj.radius > canvas.height) {
                    if (obj.type === 'NORMAL') {
                        combo = 0;
                        comboElement.innerText = 0;
                    }
                    objects.splice(i, 1); // Xóa bóng hiện tại để quả sau rơi xuống
                }
            }

            // Xử lý Powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                let pu = powerups[i];
                pu.y += pu.speedY;
                if (pu.y + pu.size > paddle.y && pu.y < paddle.y + paddle.height &&
                    pu.x > paddle.x && pu.x < paddle.x + paddle.width) {
                    applyPowerup(pu);
                    powerups.splice(i, 1);
                } else if (pu.y > canvas.height) {
                    powerups.splice(i, 1);
                }
            }

            // Xử lý Hạt
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.speedX; p.y += p.speedY; p.life -= 0.02;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = "#121235";
            ctx.lineWidth = 1;
            gridOffset = (gridOffset + 1) % 40;
            for(let x=0; x<=canvas.width; x+=40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
            for(let y=gridOffset; y<=canvas.height; y+=40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

            ctx.shadowBlur = 20;
            ctx.shadowColor = paddle.color;
            ctx.fillStyle = paddle.color;
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);
            ctx.fill();

            objects.forEach(obj => {
                ctx.shadowBlur = obj.type === 'OBSTACLE' ? 25 : 15;
                ctx.shadowColor = obj.color;
                ctx.fillStyle = obj.color;
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI*2);
                ctx.fill();
                if(obj.type === 'OBSTACLE') {
                    ctx.strokeStyle = "#ffffff"; 
                    ctx.lineWidth = 2; 
                    ctx.stroke();
                }
            });

            powerups.forEach(pu => {
                ctx.shadowBlur = 20; ctx.shadowColor = pu.color;
                ctx.fillStyle = pu.color;
                ctx.beginPath();
                ctx.arc(pu.x, pu.y, pu.size/2, 0, Math.PI*2);
                ctx.fill();
                ctx.strokeStyle = "#fff"; 
                ctx.stroke();
            });

            ctx.shadowBlur = 0;
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1.0;

            update();
            requestAnimationFrame(draw);
        }

        function createParticles(x, y, color) {
            for(let i=0; i<12; i++) {
                particles.push({
                    x, y, size: Math.random()*4+1,
                    speedX: (Math.random()-0.5)*10, speedY: (Math.random()-0.5)*10,
                    life: 1.0, color
                });
            }
        }

        function startGame() {
            initAudio();
            startOverlay.style.opacity = "0";
            setTimeout(() => {
                startOverlay.style.display = "none";
                isGameRunning = true;
                resetState();
            }, 500);
        }

        function endGame() {
            isGameRunning = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem("neonCatchHighScore", highScore);
            }
            document.getElementById("finalScoreText").innerText = "ĐIỂM SỐ: " + score;
            document.getElementById("highScoreText").innerText = "KỶ LỤC: " + highScore;
            gameOverOverlay.style.display = "flex";
            gameOverOverlay.style.opacity = "1";
        }

        function resetState() {
            score = 0; lives = 3; combo = 0; level = 1;
            objects = []; powerups = []; particles = [];
            scoreElement.innerText = 0; livesElement.innerText = 3;
            comboElement.innerText = 0; levelElement.innerText = 1;
            resetPowerupEffects();
        }

        function resetGame() {
            gameOverOverlay.style.display = "none";
            isGameRunning = true;
            resetState();
        }

        canvas.addEventListener("pointermove", e => {
            if (!isGameRunning) return;
            let rect = canvas.getBoundingClientRect();
            paddle.targetX = e.clientX - rect.left - paddle.width / 2;
            
            if(paddle.targetX < 0) paddle.targetX = 0;
            if(paddle.targetX > canvas.width - paddle.width) paddle.targetX = canvas.width - paddle.width;
        });

        requestAnimationFrame(draw);
    </script>
</body>
</html>
